# -*- coding: utf-8 -*-
"""prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FjiB0yH6Z2HxCDb8FueUlqngEo-CjF_V
"""

import torch
import torch.nn as nn
from torchvision import models, transforms
from PIL import Image
import argparse
import os
import sys

CLASSES = ("plane", "car", "bird", "cat", "deer",
           "dog", "frog", "horse", "ship", "truck")

def get_args():
    """ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã‚’è§£æã™ã‚‹"""
    parser = argparse.ArgumentParser(description='CIFAR-10 Image Classifier using ResNet50')
    parser.add_argument('--image', type=str, required=True, help='Path to the input image file')
    parser.add_argument('--weights', type=str, default='experiment_adjustment.pth', help='Path to the trained model weights (.pth)')
    parser.add_argument('--device', type=str, default='auto', choices=['auto', 'cpu', 'cuda'], help='Device to use for inference')
    return parser.parse_args()

def load_model(weights_path, device):
    """ãƒ¢ãƒ‡ãƒ«ã‚’æ§‹ç¯‰ã—ã€å­¦ç¿’æ¸ˆã¿é‡ã¿ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹"""
    print(f"ğŸ—ï¸  Building ResNet50 model...")

    # 1. ãƒ¢ãƒ‡ãƒ«ã®æ çµ„ã¿ã‚’ä½œæˆï¼ˆé‡ã¿ã¯ç©ºã§OKï¼‰
    model = models.resnet50(weights=None)

    # 2. æœ€çµ‚å±¤ã‚’CIFAR-10ç”¨ï¼ˆ10ã‚¯ãƒ©ã‚¹ï¼‰ã«æ›¸ãæ›ãˆ
    # â€» å­¦ç¿’æ™‚ã¨åŒã˜æ§‹é€ ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™
    model.fc = nn.Linear(model.fc.in_features, 10)

    # 3. é‡ã¿ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ­ãƒ¼ãƒ‰
    if not os.path.exists(weights_path):
        print(f"âŒ Error: Weights file not found at '{weights_path}'")
        sys.exit(1)

    print(f"DTO Loading weights from '{weights_path}'...")
    try:
        # map_locationã‚’ä½¿ã†ã“ã¨ã§ã€GPUã§å­¦ç¿’ã—ãŸãƒ¢ãƒ‡ãƒ«ã‚’CPUã—ã‹ç„¡ã„ç’°å¢ƒã§ã‚‚ãƒ­ãƒ¼ãƒ‰å¯èƒ½ã«ã—ã¾ã™
        state_dict = torch.load(weights_path, map_location=device)
        model.load_state_dict(state_dict)
    except Exception as e:
        print(f"âŒ Error loading state_dict: {e}")
        sys.exit(1)

    model.to(device)
    model.eval() # â˜…è¶…é‡è¦ï¼šè©•ä¾¡ãƒ¢ãƒ¼ãƒ‰ã«ã™ã‚‹ï¼ˆDropoutã‚„Batch Normã‚’å›ºå®šï¼‰
    return model

def preprocess_image(image_path):
    """ç”»åƒã‚’èª­ã¿è¾¼ã¿ã€ãƒ¢ãƒ‡ãƒ«ã«å…¥åŠ›ã§ãã‚‹å½¢å¼ã«å¤‰æ›ã™ã‚‹"""
    # å­¦ç¿’æ™‚ã® 'val_transform' ã¨åŒã˜å‡¦ç†ã‚’è¡Œã„ã¾ã™
    transform = transforms.Compose([
        transforms.Resize(224), # ResNet50ã®å…¥åŠ›ã‚µã‚¤ã‚ºã«åˆã‚ã›ã‚‹
        transforms.ToTensor(),
        transforms.Normalize((0.485, 0.456, 0.406), (0.229, 0.224, 0.225))
    ])

    if not os.path.exists(image_path):
        print(f"âŒ Error: Image file not found at '{image_path}'")
        sys.exit(1)

    try:
        image = Image.open(image_path).convert('RGB') # pngãªã©ã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒãƒ£ãƒ³ãƒãƒ«å¯¾ç­–
        input_tensor = transform(image)
        input_batch = input_tensor.unsqueeze(0) # ãƒãƒƒãƒæ¬¡å…ƒã‚’è¿½åŠ  [3, 224, 224] -> [1, 3, 224, 224]
        return input_batch
    except Exception as e:
        print(f"âŒ Error processing image: {e}")
        sys.exit(1)

def main():
    args = get_args()

    # ãƒ‡ãƒã‚¤ã‚¹ã®æ±ºå®š
    if args.device == 'auto':
        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    else:
        device = torch.device(args.device)

    print(f"âš™ï¸  Using device: {device}")

    # ãƒ¢ãƒ‡ãƒ«ã¨ç”»åƒã®æº–å‚™
    model = load_model(args.weights, device)
    input_batch = preprocess_image(args.image).to(device)

    # æ¨è«–å®Ÿè¡Œ
    print(f"ğŸ” Predicting...")
    with torch.no_grad(): # å‹¾é…è¨ˆç®—ã‚’ç„¡åŠ¹åŒ–ã—ã¦ãƒ¡ãƒ¢ãƒªç¯€ç´„ãƒ»é«˜é€ŸåŒ–
        output = model(input_batch)
        probabilities = torch.nn.functional.softmax(output[0], dim=0)

    # ä¸Šä½3ã¤ã®äºˆæ¸¬ã‚’è¡¨ç¤º
    top_prob, top_catid = torch.topk(probabilities, 3)

    print("\n" + "="*30)
    print(f"ğŸ–¼ï¸  Input: {args.image}")
    print("="*30)
    print(f"ğŸ† Top 1: {CLASSES[top_catid[0]]:<10} ({top_prob[0].item()*100:.2f}%)")
    print("-" * 30)

    # 2ä½ã¨3ä½ã‚‚è¡¨ç¤ºï¼ˆãƒ‡ãƒãƒƒã‚°ã‚„ç¢ºèªã«ä¾¿åˆ©ï¼‰
    for i in range(1, 3):
        print(f"   Top {i+1}: {CLASSES[top_catid[i]]:<10} ({top_prob[i].item()*100:.2f}%)")
    print("="*30 + "\n")

if __name__ == "__main__":
    main()